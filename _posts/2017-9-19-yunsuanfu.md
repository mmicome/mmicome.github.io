---
layout: post
title: "js 运算符"
date: 2017-9-19
description: "js 运算符"
tag: js
comments: true
---
#### 加法运算符

加法运算符（+）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接，它们都写成+。

    ```js
    // 加法
    1 + 1 // 2
    true + true // 2
    1 + true // 2

    // 字符串连接
    '1' + '1' // "11"
    '1.1' + '1.1' // "1.11.1"
    ```

它的算法步骤如下。

如果运算子是对象，先自动转成原始类型的值（即先执行该对象的valueOf方法，如果结果还不是原始类型的值，再执行toString方法；如果对象是Date实例，则先执行toString方法）。

    ```js
    o3={
      valueOf:function(){
        return {
          toString:function(){
            return 3;
          }
        };
      },
      toString:function(){
        return 1;
      }
    }
    o3>2//false
    o3<2//true
    ```

两个运算子都是原始类型的值以后，只要有一个运算子是字符串，则两个运算子都转为字符串，执行字符串连接运算。
否则，两个运算子都转为数值，执行加法运算。
下面是一些例子。

    ```js
    '1' + {foo: 'bar'} // "1[object Object]"
    '1' + 1 // "11"
    '1' + true // "1true"
     1  + true; //2
    '1' + [1] // "11"
    ```

#### 对象

如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，详细解释参见《数据类型的转换》一节。

    ```js
    var x = [2];
    x > '11' // true
    // 等同于 [2].valueOf().toString() > '11'
    // 即 '2' > '11'

    x.valueOf = function () { return '1' };
    x > '11' // false
    // 等同于 [2].valueOf() > '11'
    // 即 '1' > '11'
    ```

    ```js
    [2] > [1] // true
    // 等同于 [2].valueOf().toString() > [1].valueOf().toString()
    // 即 '2' > '1'

    [2] > [11] // true
    // 等同于 [2].valueOf().toString() > [11].valueOf().toString()
    // 即 '2' > '11'

    {x: 2} >= {x: 1} // true
    // 等同于 {x: 2}.valueOf().toString() >= {x: 1}.valueOf().toString()
    // 即 '[object Object]' >= '[object Object]'
    ```

**注意，Date 对象实例用于比较时，是先调用toString方法。如果返回的不是原始类型的值，再接着对返回值调用valueOf方法。**

#### 对象与原始类型值比较

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。

    ```js
    [1] == 1 // true
    // 等同于 Number([1]) == 1

    [1] == '1' // true
    // 等同于 String([1]) == Number('1')

    [1] == true // true
    // 等同于 Number([1]) == Number(true)

    !!x
    // 等同于
    Boolean(x)
    ```

有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。

    ```js
    if (i) {
      doSomething();
    }

    // 等价于

    i && doSomething();
    ```

位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。

    ```js
    i = i | 0;
    //上面这行代码的意思，就是将i（不管是整数或小数）转为32位整数。

    function toInt32(x) {
      return x | 0;
    }

    toInt32(1.001) // 1
    toInt32(1.999) // 1
    toInt32(1) // 1
    toInt32(-1) // -1
    toInt32(Math.pow(2, 32) + 1) // 1
    toInt32(Math.pow(2, 32) - 1) // -1
    ```

上面代码中，最后两行得到1和-1，是因为一个整数大于32位的数位都会被舍去。

“或运算”与“与运算”
这两种运算比较容易理解，就是逐位比较两个运算子。“或运算”的规则是，两个二进制位之中只要有一个为1，就返回1，否则返回0。“与运算”的规则是，两个二进制位之中只要有一个位为0，就返回0，否则返回1。

    ```js
    0 | 3 // 3
    0 & 3 // 0
    ```

上面两个表达式，0和3的二进制形式分别是00和11，所以进行“或运算”会得到11（即3），进行“与运算”会得到00（即0）。

位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行或运算，等同于对该数去除小数部分，即取整数位。

    ```js
    2.9 | 0 // 2
    -2.9 | 0 // -2
    //需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。

    2147483649.4 | 0;
    // -2147483647
    ```

##### 否运算

“否运算”将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。`~ 3 // -4`

上面表达式对3进行“否运算”，得到-4。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。3在JavaScript内部是00000000000000000000000000000011，否运算以后得到11111111111111111111111111111100，由于第一位是1，所以这个数是一个负数。JavaScript内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。

所有的位运算都只对整数有效。否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次否运算，能达到取整效果。

    ```js
    ~~2.9 // 2
    ~~47.11 // 47
    ~~1.9999 // 1
    ~~3 // 3
    ```

使用否运算取整，是所有取整方法中最快的一种。
位运算符的取整效果与Math.floor并不完全相同，位运算符是直接舍弃小数位，而Math.floor则是向下取整，所以对负小数的效果就不一样了。

    ```js
    ~~(-2.4) // -2
    Math.floor(-2.4) // -3
    ```

对字符串进行否运算，JavaScript引擎会先调用Number函数，将字符串转为数值。

    ```js
    // 以下例子相当于~Number('011')
    ~'011'  // -12
    ~'42 cats' // -1
    ~'0xcafebabe' // 889275713
    ~'deadbeef' // -1

    // 以下例子相当于~~Number('011')
    ~~'011';        // 11
    ~~'42 cats';    // 0
    ~~'0xcafebabe'; // -889275714
    ~~'deadbeef';   // 0
    ```

Number函数将字符串转为数值的规则，参见《数据的类型转换》一节。否运算对特殊数值的处理是：超出32位的整数将会被截去超出的位数，NaN和Infinity转为0。

对于其他类型的参数，否运算也是先用Number转为数值，然后再进行处理。

    ```js
    ~~[] // 0
    ~~NaN // 0
    ~~null // 0
    ```

“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，aˆ=b, bˆ=a, aˆ=b，可以互换它们的值

    ```js
    var a = 10;
    var b = 99;

    a ^= b, b ^= a, a ^= b;

    a // 99
    b // 10

    //other way:
    a=[b,b=a][0];
    ```

这是互换两个变量的值的最快方法。

异或运算也可以用来取整。`12.9 ^ 0 // 12`

如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。

    ```js
    13.5 << 0
    // 13

    -13.5 << 0
    // -13
    ```

左移运算符用于二进制数值非常方便。

    ```js
    var color = {r: 186, g: 218, b: 85};

    // RGB to HEX
    // (1 << 24)的作用为保证结果是6位数
    var rgb2hex = function(r, g, b) {
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
        .toString(16)
        .substr(1);
    }

    rgb2hex(color.r,color.g,color.b)
    // "#bada55"
    ```

开关作用

位运算符可以用作设置对象属性的开关。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

    ```js
    var FLAG_A = 1; // 0001
    var FLAG_B = 2; // 0010
    var FLAG_C = 4; // 0100
    var FLAG_D = 8; // 1000
    ```

上面代码设置A、B、C、D四个开关，每个开关分别占有一个二进制位。

然后，就可以用“与运算”检验，当前设置是否打开了指定开关。

    ```js
    var mask = FLAG_A | FLAG_B | FLAG_D;
    // 0001 | 0010 | 1000 => 1011
    ```

上面代码对ABD三个变量进行“或运算”，得到掩码值为二进制的1011。

有了掩码，“或运算”可以确保打开指定的开关。

`flags = flags | mask;`

“与运算”可以将当前设置中凡是与开关设置不一样的项，全部关闭。

`flags = flags & mask;`

“异或运算”可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

`flags = flags ^ mask;`

“否运算”可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。

`flags = ~flags;`

下面是常见的网页中触发鼠标点击事件的写法。

`<a href="http://example.com" onclick="f();">文字</a>`

上面代码有一个问题，函数f必须返回false，或者说onclick事件必须返回false，否则会引起浏览器跳转到example.com。

    ```js
    function f() {
      // some code
      return false;
    }
    //或者写成

    <a href="http://example.com" onclick="f();return false;">文字</a>
    ```

void运算符可以取代上面两种写法。

`<a href="javascript: void(f())">文字</a>`

下面的代码会提交表单，但是不会产生页面跳转。

`<a href="javascript: void(document.form.submit())">文字</a>`

函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。

    ```js
    function f() {
      return 1;
    }

    (f) // function f(){return 1;}
    f() // 1
    ```

    ```js
    var d = new Date();
    console.log(d.valueOf());
    var d2 = (d);
    console.log(d2);
    console.log(d2 === d.valueOf()); // false
    ```
