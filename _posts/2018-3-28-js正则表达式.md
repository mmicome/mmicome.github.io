---
layout: post
title: "js正则表达式"
date: 2018-3-28
description: "js正则表达式"
tag: node
comments: true
---

重要声明 「此文仅用于知识点整理，不用于传播」

### js正则表达式语法

1. 正则表达式规则

1.1 普通字符

    字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。

    举例1：表达式 "c"，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："c"；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）

    举例2：表达式 "bcd"，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："bcd"；匹配到的位置是：开始于1，结束于4。

1.2 简单的转义字符

    一些不便书写的字符，采用在前面加 "/" 的方法。这些字符其实我们都已经熟知了。

    /r, /n ：   代表回车和换行符

    /t     ：   制表符

    //     ：   代表 "/" 本身

    还有其他一些在后边章节中有特殊用处的标点符号，在前面加 "/" 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 "^" 和 "$" 字符，则表达式就需要写成 "/^" 和 "/$"。


    /^     ：   匹配 ^ 符号本身

    /$     ：   匹配 $ 符号本身

    /.     ：   匹配小数点（.）本身

    这些转义字符的匹配方法与 "普通字符" 是类似的。也是匹配与之相同的一个字符。

    举例1：表达式 "/$d"，在匹配字符串 "abc$de" 时，匹配结果是：成功；匹配到的内容是："$d"；匹配到的位置是：开始于3，结束于5。

1.3 能够与 '多种字符' 匹配的表达式

    正则表达式中的一些表示方法，可以匹配 '多种字符' 其中的任意一个字符。比如，表达式 "/d" 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。

    /d     ：   任意一个数字，0~9 中的任意一个

    /w     ：   任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个

    /s     ：    包括空格、制表符、换页符等空白字符的其中任意一个

    .      ：    小数点可以匹配除了换行符（/n）以外的任意一个字符

    举例1：表达式 "/d/d"，在匹配 "abc123" 时，匹配的结果是：成功；匹配到的内容是："12"；匹配到的位置是：开始于3，结束于5。

    举例2：表达式 "a./d"，在匹配 "aaa100" 时，匹配的结果是：成功；匹配到的内容是："aa1"；匹配到的位置是：开始于1，结束于4。

1.4 自定义能够匹配 '多种字符' 的表达式

    使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。

    [ab5@]         匹配 "a" 或 "b" 或 "5" 或 "@"

    [^abc]         匹配 "a","b","c" 之外的任意一个字符

    [f-k]          匹配 "f"~"k" 之间的任意一个字母

    [^A-F0-3]      匹配 "A"~"F","0"~"3" 之外的任意一个字符

1.5 修饰匹配次数的特殊符号

    前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。

    使用方法是："次数修饰"放在"被修饰的表达式"后边。比如："[bcd][bcd]" 可以写成 "[bcd]{2}"。

    {n}            表达式重复n次，比如："/w{2}" 相当于 "/w/w"；"a{5}" 相当于 "aaaaa"

    {m,n}          表达式至少重复m次，最多重复n次，比如："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"

    {m,}           表达式至少重复m次，比如："/w/d{2,}"可以匹配 "a12","_456","M12344"...

    ?              匹配表达式0次或者1次，相当于 {0,1}，比如："a[cd]?"可以匹配 "a","ac","ad"

    +              表达式至少出现1次，相当于 {1,}，比如："a+b"可以匹配 "ab","aab","aaab"...

    *              表达式不出现或出现任意次，相当于 {0,}，比如："/^*b"可以匹配 "b","^^^b"...

    举例1：表达式 "/d+/.?/d*" 在匹配 "It costs $12.5" 时，匹配的结果是：成功；匹配到的内容是："12.5"；匹配到的位置是：开始于10，结束于14。

    举例2：表达式 "Go{2,8}gle" 在匹配 "Ads by goooooogle" 时，匹配的结果是：成功；匹配到的内容是："goooooogle"；匹配到的位置是：开始于7，结束于17。

1.6 其他一些代表抽象意义的特殊符号


    ^      与字符串开始的地方匹配，不匹配任何字符

    $      与字符串结束的地方匹配，不匹配任何字符

    /b     匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符

    举例1：表达式 "^aaa" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "^" 要求与字符串开始的地方匹配，因此，只有当 "aaa" 位于字符串的开头的时候，"^aaa" 才能匹配，比如："aaa xxx xxx"。

    举例2：表达式 "aaa$" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "$" 要求与字符串结束的地方匹配，因此，只有当 "aaa" 位于字符串的结尾的时候，"aaa$" 才能匹配，比如："xxx xxx aaa"。

    举例3：表达式 "./b." 在匹配 "@@@abc" 时，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。

    进一步说明："/b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "/w" 范围，另一边是 非"/w" 的范围。

    举例4：表达式 "/bend/b" 在匹配 "weekend,endfor,end" 时，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18。

1.7 一些符号可以影响表达式内部的子表达式之间的关系：

    |        左右两边表达式之间 "或" 关系，匹配左边或者右边

    ( )      (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
             (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到


    举例5：表达式 "Tom|Jack" 在匹配字符串 "I'm Tom, he is Jack" 时，匹配结果是：成功；匹配到的内容是："Tom"；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是："Jack"；匹配到的位置时：开始于15，结束于19。

    举例6：表达式 "(go/s*)+" 在匹配 "Let's go go go!" 时，匹配结果是：成功；匹配到内容是："go go go"；匹配到的位置是：开始于6，结束于14。

    举例7：表达式 "￥(/d+/.?/d*)" 在匹配 "＄10.9,￥20.5" 时，匹配的结果是：成功；匹配到的内容是："￥20.5"；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是："20.5"。

2. 正则表达式中的一些高级规则

2.1 匹配次数中的贪婪与非贪婪

    在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如："{m,n}", "{m,}", "?", "*", "+"，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 "dxxxdxxxd"，举例如下：

    (d)(/w+)        "/w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"

    (d)(/w+)(d)     "/w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "/w+"                   也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"/w+" 可以 "让出" 它本                  来能够匹配的最后一个 "d"

    由此可见，"/w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "*" 和 "{m,n}" 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这 种匹配原则就叫作 "贪婪" 模式 。

    非贪婪模式：

    在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：

    (d)(/w+?)         "/w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："/w+?" 只匹配了一个 "x"

    (d)(/w+?)(d)       为了让整个表达式匹配成功，"/w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，                    从而使整个表达式匹配成功。因此，结果是："/w+?" 匹配 "xxx"


    举例1：表达式 "<td>(.*)</td>" 与字符串 "<td><p>aa</p></td> <td><p>bb</p></td>" 匹配时，匹配的结果是：成功；匹配到的内容是 "<td><p>aa</p></td> <td><p>bb</p></td>" 整个字符串， 表达式中的 "</td>" 将与字符串中最后一个 "</td>" 匹配。 

    举例2：相比之下，表达式 "<td>(.*?)</td>" 匹配举例1中同样的字符串时，将只得到 "<td><p>aa</p></td>"， 再次匹配下一个时，可以得到第二个 "<td><p>bb</p></td>"。

2.2 反向引用 /1, /2...

    表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 "<td>(.*?)</td>"。

    其实，"小括号包含的表达式所匹配到的字符串" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "/" 加上一个数字。"/1" 引用第1对括号内匹配到的字符串，"/2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。

    举例1：表达式 "('|")(.*?)(/1)" 在匹配 " 'Hello', "World" " 时，匹配结果是：成功；匹配到的内容是：" 'Hello' "。再次匹配下一个时，可以匹配到 " "World" "。

    举例2：表达式 "(/w)/1{4,}" 在匹配 "aa bbbb abcdefg ccccc 111121111 999999999" 时，匹配结果是：成功；匹配到的内容是 "ccccc"。再次匹配下一个时，将得到 999999999。这个表达式要求 "/w" 范围的字符至少重复5次，注意与 "/w{5,}" 之间的区别。

    举例3：表达式 "<(/w+)/s*(/w+(=('|").*?/4)?/s*)*>.*?<//1>" 在匹配 "<td id='td1' style="bgcolor:white"></td>" 时，匹配结果是成功。如果 "<td>" 与 "</td>" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。

3. 其他通用规则

    还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。

3.1 表达式中，可以使用 "/xXX" 和 "/uXXXX" 表示一个字符（"X" 表示一个十六进制数）

    /xXX     编号在 0 ~ 255 范围的字符，比如：空格可以使用 "/x20" 表示

    /uXXXX    任何字符可以使用 "/u" 再加上其编号的4位十六进制数表示，比如："/中"

3.2 在表达式 "/s"，"/d"，"/w"，"/b" 表示特殊意义的同时，对应的大写字母表示相反的意义

    /S     匹配所有非空白字符（"/s" 可匹配各个空白字符）

    /D     匹配所有的非数字字符

    /W     匹配所有的字母、数字、下划线以外的字符

    /B     匹配非单词边界，即左右两边都是 "/w" 范围或者左右两边都不是 "/w" 范围时的字符缝隙

3.3 在表达式中有特殊意义，需要添加 "/" 才能匹配该字符本身的字符汇总

    ^       匹配输入字符串的开始位置。要匹配 "^" 字符本身，请使用 "/^"

    $       匹配输入字符串的结尾位置。要匹配 "$" 字符本身，请使用 "/$"

    ( )     标记一个子表达式的开始和结束位置。要匹配小括号，请使用 "/(" 和 "/)"

    [ ]     用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 "/[" 和 "/]"

    { }     修饰匹配次数的符号。要匹配大括号，请使用 "/{" 和 "/}"

    .       匹配除了换行符（/n）以外的任意一个字符。要匹配小数点本身，请使用 "/."

    ?       修饰匹配次数为 0 次或 1 次。要匹配 "?" 字符本身，请使用 "/?"

    +       修饰匹配次数为至少 1 次。要匹配 "+" 字符本身，请使用 "/+"

    *       修饰匹配次数为 0 次或任意次。要匹配 "*" 字符本身，请使用 "/*"

    |       左右两边表达式之间 "或" 关系。匹配 "|" 本身，请使用 "/|"



3.4 括号 "( )" 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 "(?:xxxxx)" 格式

    举例1：表达式 "(?:(/w)/1)+" 匹配 "a bbccdd efg" 时，结果是 "bbccdd"。括号 "(?:)" 范围的匹配结果不进行记录，因此 "(/w)" 使用 "/1" 来引用。

3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global

- Ignorecase

默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 "大小写" 概念延伸至 UNICODE 范围的大小写。

- Singleline

默认情况下，小数点 "." 匹配除了换行符（/n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。

- Multiline

默认情况下，表达式 "^" 和 "$" 只匹配字符串的开始 ① 和结尾 ④ 位置。如：

①xxxxxxxxx②/n
③xxxxxxxxx④

配置为 Multiline 可以使 "^" 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 "$" 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。

- Global

主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。


4. 其他提示

4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见本站 DEELX 正则引擎的说明文档。

4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 "^" 和 "$"，比如："^/d+$" 要求整个字符串只有数字。

4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 "/b"，比如：使用 "/b(if|while|else|void|int……)/b" 来匹配程序中的关键字。

4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 "123"、"123."、"123.5"、".5" 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成："/d*/.?/d*"，因为如果什么都没有，这个表达式也可以匹配成功。更好的写法是："/d+/.?/d*|/./d+"。

4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。

4.6 合理选择贪婪模式与非贪婪模式，参见话题讨论。

4.7 或 "|" 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 "|" 两边的表达式因为交换位置而有所不同。

[资源](http://www.regexlab.com/)

### JS正则处理函数

方式一：直接量语法

`var reg = /pattern/attributes`

方式二：创建 RegExp 对象的语法

` var reg = new RegExp(pattern, attributes);`

参数说明：

    参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。 
    参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。

两者区别在于： 

    1.采用直接量语法新建的正则表达式对象在代码编译时就会生成，是平常开发中常用的方式； 
    2.采用构造函数生成的正则对象要在代码运行时生成。

正则表达式使用： 

    正则对象的方法是指这样使用的： RegExp对象.方法(字符串) 
    字符串对象的方法是这样使用：字符串.方法(RegExp对象)

属性

    ignoreCase 返回布尔值，表示RegExp 对象是否具有标志 i
    global 返回布尔值，表示RegExp对象是否具有标志g
    multiline 返回布尔值，表示RegExp 对象是否具有标志 m。
    lastIndex 一个整数，标识开始下一次匹配的字符位置
    source 返回正则表达式的源文本（不包括反斜杠）

    i 执行对大小写不敏感的匹配

    g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
    m 执行多行匹配

方法

- test方法

    如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。

    如果正则表达式是一个空字符串，则会匹配所有的字符串，但需要使用new RegExp()方式
    `console.log(new RegExp('').test('abc'));//true`

- exec方法

    exec() 方法用于检索字符串中的正则表达式的匹配。

    返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。

    var res1 = reg1.exec("xyz");
    console.log(res1);//["x", index: 0, input: "xyz"]

    如果正则表达式包含圆括号，则返回的数组会包括多个元素。首先是整个匹配成功的结果，后面是圆括号里匹配成功的结果，如果有多个圆括号，他们的匹配成功的结果都会成为数组元素

- RegExp.prototype.compile() ——编译正则表达式

功能说明：compile() 方法用于在脚本执行过程中编译正则表达式，也可用于改变和重新编译正则表达式。该方法可以编译指定的正则表达式，编译之后的正则表达式执行速度将会提高，如果正则表达式多次被调用，那么调用compile方法可以有效的提高代码的执行速度，如果该正则表达式只能被使用一次，则不会有明显的效果。

    var str="Every man in the world! Every woman on earth!";
    var patt=/man/g;
    var str2=str.replace(patt,"person");
    document.write(str2+"<br>");
    patt=/(wo)?man/g;
    patt.compile(patt); 
    str2=str.replace(patt,"person");
    document.write(str2);
    结果：
    Every person in the world! Every woperson on earth!
    Every person in the world! Every person on earth!


### 支持正则表达式的 String 对象的方法

- search方法

    search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。

    返回值： stringObject 中第一个与 regexp 相匹配的子串的起始位置。

    注释：如果没有找到任何匹配的子串，则返回 -1。

    search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。

- match() 方法
    
    可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

    该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。

    字符串对象的match方法与正则对象的exec方法比较类似：

    但是如果正则表达式带有g修饰符，那么match方法与exec方法就有差别了:

    可以看到match返回了所有成功匹配的结果，但是exec方法只返回了一个。 

    ```js
    var str = "abcdabc";
    var reg = /a/g;
    console.log(str.match(reg));//["a", "a"]
    console.log(reg.exec(str));//["a", index: 0, input: "abcdabc"] 
    ```   

- replace

    replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

    返回值：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。

    字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

    var str = "javascript";
    str.replace(/(java)(script)/,'$2$1');
    str.replace(/java/, '$&-')
    str.replace(/ava/, '$`')  //jjscript
    str.replace(/ava/, "$'")   //jscriptscript

- split方法

split(‘字符串的分割正则','返回数组的最大成员数')；返回分割后各部分组成的数组 

    var str = 'a,b , c,d';
    var res = str.split(",");//以逗号来分割字符串
    console.log(res);//["a", "b ", " c", "d"]

    var str1 = 'a,b , c,,d';
    var res1 = str1.split(/,*/);//以0或多个逗号来分割字符串
    console.log(res1);//["a", "b", " ", " ", "c", "d"]

    var str2 = 'a, b,c, d';
    var res2 = str2.split(/, */);//以0或对个逗号空格来分割字符串
    console.log(res2);//["a", "b", "c", "d"]

    var str3 = 'a, b,c, d';
    var res3 = str3.split(/, */,2);//以0或对个逗号空格来分割字符串，同时限制返回数组中最多有两项
    console.log(res3);//["a", "b"]



### js正则常用

    通常用于两种任务：

    1.验证 
    用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；

    2.搜索替换 
    搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$

1.只能输入数字和英文的：

    <input onkeyup="value=value.replace(/[\W]/g,'') " onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\d]/g,''))" ID="Text1" NAME="Text1">

2.只能输入数字的：

    <input onkeyup="value=value.replace(/[^\d]/g,'') " onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\d]/g,''))" ID="Text2" NAME="Text2">

3.只能输入全角的：

    <input onkeyup="value=value.replace(/[^\uFF00-\uFFFF]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\uFF00-\uFFFF]/g,''))" ID="Text3" NAME="Text3">

4.只能输入汉字的：

    <input onkeyup="value=value.replace(/[^\u4E00-\u9FA5]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\u4E00-\u9FA5]/g,''))" ID="Text4" NAME="Text4">

**注意：重要的表单数据必须服务端验证，前端代码在用户可修改的情况下无法保证规则的有效性**

5.校验URL

`/^http[s]?:\/\/.+$/`

6.校验纯中文字符

`^[\u4E00-\u9FA5]+$/`

7.给字符串加千分符

`"str.replace(/\B(?=(?:\d{3})+$)/g", ',')`

    如果拿这个正则表达式匹配 123456789，匹配的步骤如下：

    “123,456798" （3 和 4 中间的位置是 \B，且之后的一串数字长度为三的倍数）

    "123,456,789" （6 和 7 中间的位置满足）

    //或者

    `/(?=(?!\b)(\d{3})+$)/g`

正則表常用

```js
"^\d+$"　　                          //非负整数（正整数 + 0） 
"^[0-9]*[1-9][0-9]*$"　　            //正整数 
"^[1-9]\d*"                         //正整数
"^((-\d+)|(0+))$"　　                //非正整数（负整数 + 0） 
"^-[0-9]*[1-9][0-9]*$"　　           //负整数 
"^-?\d+$"　　　　                     //整数 
"^\d+(\.\d+)?$"　　                  //非负浮点数（正浮点数 + 0） 

"^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　                                         //正浮点数 
"^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$"    //正浮点数 

"^((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　 //非正浮点数（负浮点数 + 0） 

"^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　                                       　//负浮点数 

"^(-?\d+)(\.\d+)?$"　　              //浮点数 
"^[A-Za-z]+$"　　                    //由26个英文字母组成的字符串 
"^[A-Z]+$"　　                       //由26个英文字母的大写组成的字符串 
"^[a-z]+$"　　                       //由26个英文字母的小写组成的字符串 
"^[A-Za-z0-9]+$"　　                 //由数字和26个英文字母组成的字符串 
"^\w+$"　　                          //由数字、26个英文字母或者下划线组成的字符串 

"^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　             //email地址 
"^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　   //url
"^(\d{2}|\d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$"                                                                               //  年-月-日
"^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$"                                                                                // 月/日/年
"^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$"                                                        //Emil
"(\d+-)?(\d{4}-?\d{7}|\d{3}-?\d{8}|^\d{7,8})(-\d+)?"       //电话号码

"^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1dd|2[0-4]\d|25[0-5])$"               //IP地址

"^([0-9A-F]{2})(-[0-9A-F]{2}){5}$"                           //MAC地址的正则表达式
"^[-+]?\d+(\.\d+)?$"                                         //值类型正则表达式
"[1-9]\d{5}(?!\d)"                                           //匹配邮政编码
"/^(\d{14}|\d{17})(\d|[xX])$"                                //匹配身份证

```
数字相关的正则表达式

    数字：^[0-9]*$
    n位定长的数字：^\d{n}$
    m-n位之间的数字：^\d{m,n}$
    零和非零开头的数字：^(0|[1-9][0-9]*)$
    非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
    带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
    正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
    有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
    有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
    正整数：^\d+$ 或 ^[1-9]\d*|0$
    负整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
    正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
    负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
    浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$


字符相关的正则表达式

    汉字：^[\u4e00-\u9fa5]{0,}$
    长度为3-20的所有字符：^.{3,20}$
    由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
    由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
    中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
    中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
    帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
    密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
    强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

固定格式约定俗成的正则表达式

    Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
    网站域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
    URL网址：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
    手机号码：^(13[0-9]|17[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
    电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
    国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
    身份证号(15位、18位数字)：^\d{15}|\d{18}$
    日期格式：^\d{4}-\d{1,2}-\d{1,2}
    一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
    一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
    腾讯QQ号：[1-9][0-9]{4,8} (腾讯QQ号从10000开始，目前最长为10位)
    中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
    IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
    IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

### js正则项目实例

1. 去除首尾的'/'

    input. input.replace(/^\/*|\/*$/g, '')

2. 匹配一段引号内容

    var str = 'asdf html-webpack-plugin for "index/index.html" asdfasdf';
    str.match(/html-webpack-plugin for \"(.*)\"/gi);
    console.log(RegExp.$1) //=>index/index.html

3. 匹配括号内容

    'max_length(12)'.match(/^.+?\((.+)\)$/)

4. 调换

    var name = "Doe, John";
    name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");

5. 字符串截取

    var str = 'asfdf === sdfad ##'
    str.match(/[^(?:===)]+(?=(?:===))/g)   // 截取 ===之前的内容
    str.match(/\n/g, '')   // 替换字符串中的 \n 换行字符

6. 小数点后几位验证

// 精确到1位小数
/^[1-9][0-9]*$|^[1-9][0-9]*\.[0-9]$|^0\.[0-9]$/.test(1.2);

// 精确到2位小数
/^[0-9]+(.[0-9]{2})?$/.test(1.221);

7. 密码强度正则

// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。
/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/.test("weeeeeeeW2");
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/.test("diaoD123#");
//输出 true

8. 校验中文

/^[\u4e00-\u9fa5]{0,}$/.test("但是d"); //false
/^[\u4e00-\u9fa5]{0,}$/.test("但是"); //true
/^[\u4e00-\u9fa5]{0,}$/.test("但是"); //true

9. 包含中文正则

/[\u4E00-\u9FA5]/.test("但是d") //true
由数字、26个英文字母或下划线组成的字符串
/^\w+$/.test("ds2_@#"); // false

10. 身份证号正则
//身份证号（18位）正则
/^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/.test("42112319870115371X");
//输出 false

11. 校验日期

“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
// true

12. 校验文件后缀

  var strRegex = "(.jpg|.gif|.txt)";
  var re=new RegExp(strRegex);
  if (re.test(str)){
    
  }
/(.jpg|.gif)+(\?|\#|$)/.test('a/b/c.jpgsss'); //=> false
/(.jpg|.gif)+(\?|\#|$)/.test('a/b/c.jpg?'); //=> true

13. 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
/^[a-zA-Z0-9_-]{4,16}$/.test("diaodiao");
//输出 true

14. 整数正则
/^\d+$/.test("42");    //正整数正则  -> 输出 true
/^-\d+$/.test("-42");  //负整数正则  -> 输出 true
/^-?\d+$/.test("-42"); //整数正则  -> 输出 true

/^[0-9]+$/.test(25.5455) //正整数正则  -> 输出 false
// 浮点数
/^(?:[-+])?(?:[0-9]+)?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/.test(0.2)

15. 数字正则

可以是整数也可以是浮点数

/^\d*\.?\d+$/.test("42.2");     //正数正则  -> 输出 true
/^-\d*\.?\d+$/.test("-42.2");   //负数正则 -> 输出 true
/^-?\d*\.?\d+$/.test("-42.2");  //数字正则 -> 输出 true

16. Email正则

//Email正则
/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/.test("wowohoo@qq.com");
//输出 true

// 1.邮箱以a-z、A-Z、0-9开头，最小长度为1.
// 2.如果左侧部分包含-、_、.则这些特殊符号的前面必须包一位数字或字母。
// 3.@符号是必填项
// 4.右则部分可分为两部分，第一部分为邮件提供商域名地址，第二部分为域名后缀，现已知的最短为2位。
//   最长的为6为。
// 5.邮件提供商域可以包含特殊字符-、_、.
/^[a-z0-9]+([._\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$/.test("wowohoo@qq.com");

17. 传真号码
// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)
/^(([0\+]\d{2,3}-)?(0\d{2,3})-)(\d{7,8})(-(\d{3,}))?$/.test('021-5055455')

18. 手机号码正则
//手机号正则
/^1[34578]\d{9}$/.test("13611778887");
//输出 true

//* 13段：130、131、132、133、134、135、136、137、138、139
//* 14段：145、147
//* 15段：150、151、152、153、155、156、157、158、159
//* 17段：170、176、177、178
//* 18段：180、181、182、183、184、185、186、187、188、189
//* 国际码 如：中国(+86)
/^((\+?[0-9]{1,4})|(\(\+86\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\d{8}$/.test("13611778887");

19. URL正则
//URL正则
/^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/.test("http://wangchujiang.com");
//输出 true

//获取url中域名、协议正则 'http://xxx.xx/xxx','https://xxx.xx/xxx','//xxx.xx/xxx'
/^(http(?:|s)\:)*\/\/([^\/]+)/.test("http://www.baidu.com");

/^((http|https):\/\/(\w+:{0,1}\w*@)?(\S+)|)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/.test('https://www.baidu.com/s?wd=@#%$^&%$#')

// 必须有协议 
/^[a-zA-Z]+:\/\//.test("http://www.baidu.com");

20. 域名正则表达式
/^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$/.test('blog.csdn.net');
// 输出 true

21. Mac地址匹配
/^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/.test('dc:a9:04:77:37:20');
// 输出 true

22. 浮点数正则表达式
/[-+]?(?:\b[0-9]+(?:\.[0-9]*)?|\.[0-9]+\b)(?:[eE][-+]?[0-9]+\b)?/.test(+334.4443434343e3);
//输出 true

23. IPv4地址正则
//ipv4地址正则
/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test("192.168.130.199");
//输出 true

24. 日期格式化yyyy-MM-dd正则
/(19|20)\d\d([- /.])(0[1-9]|1[012])\2(0[1-9]|[12][0-9]|3[01])/.test('2019-09-12')
//输出 true

25. 十六进制颜色正则
//RGB Hex颜色正则
/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/.test("#b8b8b8");
//输出 true

26. QQ号码正则
//QQ号正则，5至11位
/^[1-9][0-9]{4,10}$/.test("398188661");//输出 true

27. 微信号正则
//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
/^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/.test("jslite"); //输出 true

28. 车牌号正则
//车牌号正则
/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/.test("沪B99116") //输出 true

29. 颜色值校验
// HEX 颜色正则
/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test("#ccb2b2")

JavaScript屏蔽IE后退按钮

    在你链接的时候用

    <a href="javascript:
    location.replace(url)">

JavaScript屏蔽主窗口滚动条 

    在body标签里加上
    style="overflow-y:hidden"
    JavaScript屏蔽拷屏,不断地清空剪贴板 
    在body标签里加上
    onload="setInterval('clipboardData.setData(\'Text\',\'\')',100)"

JavaScript屏蔽网站的打印功能
    <style> 
    @media print { 
    * { display: none } 
    } 
    </style>

JavaScript屏蔽IE6.0 图片上自动出现的保存图标 

    方法一：
        <META HTTP-EQUIV="imagetoolbar" CONTENT="no">
    方法二：
        `<img galleryimg="no">`

    JavaScript屏蔽页中所有的script
        `<noscrript></noscript>`

JavaScript屏蔽F5键

    <script language="javascript"> 
    <!-- 
    function document.onkeydown()  
    {  
        if ( event.keyCode==116)  
        {  
            event.keyCode = 0;  
            event.cancelBubble = true;  
            return false;  
        } 
    } 
    --> 
    </script>

### js正则高级

> js模板引擎实现原理

我们首先会想到写一个模板，我们常见的是写成这样:

    <script type="text/html" id="template">
        <p>name: {{name}}</p>
        <p>age: {{profile.age}}</p>
    </script>

当然也可以使用`<template></template>`标签，而且这个也是现在的流行趋势，拥抱模块化

基础例子：

    ```js
    <template id="template">
        <p>name: 小青年</p>
        <p>age: 22</p>
    </template>

    <div id="content"></div>

    <script>
        var isSupport = "content" in document.createElement('template');
        if(isSupport) {
            let tp1 = document.querySelector('#template');
            let content = document.querySelector('#content');
            let clone = document.importNode(tp1.content, true);
            content.appendChild(clone);
        } else {
            alert("is not support template");
        }
    </script>
    ```

> 基础模板引擎原理讲解

**我们使用js模板引擎，可以认为是在做一个MVC结构的系统，模型(model)－视图(view)－控制器(controller)。控制器(controller)作为中间部分，首先要拿到模型，这里我们需要拿到模板里面与视图相关的内容，如上面的例子中{{ }}中的内容，首先用正则查找：**

    ```js
    var data = /{{(.+?)}}/g
    while((match = data.exec(tp1)) != null) {
        console.log(match);
    }
    结果：
    "{{name}}, name"
    "{{age}}, age"
    ```

通过RegExp 对象exec()方法搜索匹配得到的是一个数组，我们可以通过match[0]表示匹配的原字符串，match[1]表示匹配的目标字符串，我们通过执行字符串替换方法就可以得到目标字符串。

    ```js
    <div id="content"></div>
    <!--HTML模板(类似MVC中的view)-->
    <script type="text/html" id="template">
        <p>name: {{name}}</p>
        <p>age: {{age}}</p>
    </script>
    <script type="text/javascript">
        // 模板引擎函数(类似MVC中的controller)
        var mtpl = function(tpl, data) {
            var re = /{{(.+?)}}/g;
            while((match = re.exec(tpl))!==null) {
                if(match[1]){
                    tpl = tpl.replace(match[0], data[match[1]])
                }else{
                    tpl = tpl.replace(match[0], '')
                }    
            }
            return tpl
        };
        // 模板数据(类似MVC中的model)
        var tpl = document.getElementById("template").innerHTML;
        document.getElementById("content").innerHTML = mtpl(tpl,{
            name: "zhaomenghuan",
            age: 22
        });
    </script>
    ```

这里我们通过data['key']的形式取值然后替换模板中的{{...}}的内容实现了一个内容的替换。上述代码很简单，基本实现了一个字符替换而已，我们上面是通过字符串替换实现了模板和数据的匹配，但是如果我们上面那个json数据是这样的：

    var data = {
        base: {
            name: 'zhaomenghuan',
            age: 22    
        },
        skills: ['html5','javascript','android']
    }

我们直接通过data[match[1]]进行显然会有问题，我们虽然可以通过data.base['name']获取，但是对于模板引擎函数封装来说是不够完善的，而且也不能执行JavaScript，好像并没有类似于一些有名的js模板引擎库中的语法功能，所以略显low。下面我们在这个基础上进行改造。

下面我们说一下一种最原始的方法，通过Function构造器实现，根据字符串创建一个函数。在一篇文章中看到说这种方法执行JavaScript性能低下，但是对于初学者来说，学习一下实现思路我觉得也是有意义的

    var fn = new Function("arg", "console.log(arg + 1);"); 
    fn(2); // outputs 3

fn可是一个货真价实的函数，它接受一个参数，函数体是console.log(arg + 1);，上面那个例子等同于：

    var fn = function(arg) {
        console.log(arg + 1);
    }
    fn(2);

我们通过new Function可以将字符串转成JavaScript执行

接着说，我们有时候参数是多个，我们虽然可以输入多个参数，但是这显然不是最好的办法，我们可以使用apply，这样我们不必显式地传参数给这个函数。比如我们前面的例子：

    var data = {
        name: 'zhaomenghuan',
        age: 22
    }
    new Function("console.log(this.name + ' is ' + this.age +' years old.');").apply(data);

结果：
"zhaomenghuan is 22 years old."

我们可以通过数组push()或者+=拼接方式将分隔的字符串连接起来，有文章中称，“在现代浏览器使用+=会比数组push方法快，在v8引擎中使用+=方法会比数组拼接快4.7倍，而在IE6-8下push比+=拼接快”。

    var r=[];
    r.push("<p>");
    r.push(this.name);
    r.push("</p><p>");
    r.push(this.age);
    r.push("</p>");
    return r.join("");

我们如果直接拼接成数组然后转成对象也可以，但是需要将<>转义，为了方便，我们有时候可以这样处理：

    var data = {
        name: "join",
        age: 20
    }
    var code = 'var r = [];\n';
    code += 'r.push("<p>");\n';
    code += 'r.push(this.name);\n';
    code += 'r.push("</p><p>");\n';
    code += 'r.push(this.age);\n';
    code += 'r.push("</p>");\n';
    code += 'return r.join("");';
    console.log(code);
    var fn = new Function(code.replace(/[\n\t\r]/g, '')).apply(data);
    console.log(fn);

    //结果 "<p>zhaomenghuan</p><p>22</p>"

**主要是两个：如何根据我们自定义的分隔字符分隔模板字符串，然后就是动态生成字符串。不过我们可以看出来这里我们还有个没有提到的是让模板能够嵌入JavaScript的语法关键词，比如if，for等，这个处理方法和上面的略有不同，需要加以判断，不过我们可以划分为解析html和js两大类。**

> **自定义分隔字符分隔模板字符**

在讲如何分割字符串前我们先看三个函数：slice|splice|split。

- String.prototype.slice() —— 从一个字符串中提取字符串并返回新字符串

    语法：str.slice(beginSlice[, endSlice])

    参数：

    beginSlice：从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度 (例如， 如果beginSlice 是 -3 则看作是: sourceLength - 3)

    endSlice：可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice会一直提取到字符串末尾。如果该参数为负数，则被看作是 sourceLength + endSlice，这里的 sourceLength 就是字符串的长度(例如，如果 endSlice 是 -3，则是, sourceLength - 3)。

- Array.prototype.slice()—— 把数组中一部分的浅复制（shallow copy）存入一个新的数组对象中，并返回这个新的数组。

    语法：arr.slice([begin[, end]])

    参数：

    begin：从该索引处开始提取原数组中的元素（从0开始）。
    如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。

    end：在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。
    slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则slice 会一直提取到原数组末尾。

    描述：
    slice 不修改原数组，只会返回一个包含了原数组中提取的部分元素的一个新数组。原数组的元素会按照下述规则拷贝("一级深拷贝"[one level deep]规则)：

    如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则改变将反应到新的和原来的数组中。

    对于字符串和数字来说（不是 String 和 Number 对象），slice 会拷贝字符串和数字到新的数组里。在一个数组里修改这些字符串或数字，不会影响另一个数组。

    如果向两个数组任一中添加了新元素，则另一个不会受到影响。

- Array.prototype.splice() —— 用新元素替换旧元素，以此修改数组的内容

    语法：array.splice(start, deleteCount[, item1[, item2[, ...]]])

    参数：

    start​
    从数组的哪一位开始修改内容。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位。

    deleteCount
    整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。

    itemN
    要添加进数组的元素。如果不指定，则 splice() 只删除数组元素。

    返回值：
    由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。
    描述：
    如果添加进数组的元素个数不等于被删除的元素个数，数组的长度会发生相应的改变。请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。

- String.prototype.split() —— 通过把字符串分割成子字符串来把一个 String 对象分割成一个字符串数组

    语法：string.split(separator,limit)

    我们在前面讲解【支持正则表达式的 String 对象的方法】时讲到这个方法了，这里不再赘述，列出来只为方便大家对比学习。

**这里列出的方法中对于我们分隔字符串有用的是String.prototype.slice()和String.prototype.split()，另个方法的区别在于使用slice()方法们需要知道子字符串的索引值index，使用split()方法我们需要子字符串的内容或者符合的正则表达式。很明显我们的思路就出来了，接下来我们用代码实现。**

> 基于String.prototype.slice()方法分隔字符串

我们这里参考前面的内容写一个基本函数，设置一个变量cursor作为索引值指针，每次执行完一个匹配操作，我们将指针移动一下。我们前面讲RegExp.prototype.exec()返回值时重点说到了三个参数。

若match = re.exec(str)，则有：

    match.index：匹配的对象起始位置
    match[0]：表示匹配的原字符串
    match[1]：表示匹配的目标字符串
    若我们明白了思路我们就可以写下面的代码：

    ```js
    <script type="text/html" id="template">
        <p>{{this.name}}</p>
        <p>{{this.age}}</p>
    </script>

    <script type="text/javascript">
        var compile = function(tmp, data) {
            var regexp = /{{.+?}}/g
                cursor = 0;
            
            while((match = regexp.exec(tmp)) !== null) {
                //开始标签 {{ 前的内容和结束标签 }} 后的内容
                console.log(tmp.slice(cursor, match.index));
                //开始标签{{ 和 结束标签}} 之间的内容
                console.log(match[1]);
                //每次匹配完移动指针
                cursor = match.index + match[0].length
            }
        }
        var tmp = document.querySelector('#template').innerHTML;
        compile(tp1, null);
    </script>
    ```

> 基于String.prototype.split()方法分隔字符串

    使用字符串split()方法，下面我们不使用正则作为分隔符号，这里就使用自定义符号作为分隔标准，如：

    var sTag = '{%';//开始标签
    var eTag = '%}';//结束标签
    然后我们以sTag为分隔符执行split方法：

    var matchs = tpl.split(sTag);
    返回值matchs 为一个子字符串数组，然后对数组每一个子字符串以eTag为分隔符执行split方法，进一步得到的子字符串数组分为两种类型，一种是于我们匹配子字符串参数有关的子串数组，一种是与匹配参数无关的子串数组（这种数组长度为1）。之所以要分得这么细是为了后面字符串连接时更方便的时候合适的方法连接。

```js
<script type="text/html" id="template">
    <p>name: {%this.name%}</p>
    <p>age: {%this.age%}</p>
</script>

<script type="text/javascript">
    var sTag = '{%',
        eTag = '%}',
        matchs = tmp.split(sTag);

        for(let i = 0; i<matchs.length; i++) {
            match = matchs[i].split(eTag);
            if(match.length == 1) {
                console.log(match[0]);
            } else {
                if(match[0]) {
                    console.log(match[0]);
                } 
                if(match[1]) {
                    console.log(match[1]);
                }
            }
        }
</script>
```

> **动态连接字符串**

定义一个这样的模板：

    ```js
    <script type="text/tpl" id="template">
        <p>name: {{this.name}}</p>
        <p>age: {{this.profile.age}}</p>
        {{if (this.sex) {}}
            <p>sex: {{this.sex}}</p>
        {{}}}
        <ul>
            {{for(var i in this.skills){}}
            <li>{{this.skills[i]}}</li>
            {{}}}
        </ul>
    </script>
    ```

很明显我们这个模板就相对前面的复杂得多了，但是基本思路是一样的，无非是提取{{...}}的内容，然后结合数据重新组合成新的html字符串。但是与前面不同的是我们分隔的子字符串中有三种类型：

    - 含普通html标签的子字符串（如：<p>name:）

    - 含js对象值的子字符串（如：this.name）

    - 含javascript关键字的代码片段（如：if (this.sex) {）

我们刚刚前面一直只提到了第1、2两种，这两种直接可以使用数组push方法就可以连接起来，但是第3中不能使用数组push，而是应该直接连接。
所以这里我们分两种情况：

    ```js
    var reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,;

    var code = 'var r=[];\n';
    // 解析html
    function parsehtml(line) {
        // 单双引号转义，换行符替换为空格,去掉前后的空格
        line = line.replace(/('|")/g, '\\$1').replace(/\n/g, ' ').replace(/(^\s+)|(\s+$)/g,"");
        code +='r.push("' + line + '");\n';
    }

    // 解析js代码        
    function parsejs(line) {   
        // 去掉前后的空格
        line = line.replace(/(^\s+)|(\s+$)/g,"");
        code += line.match(reExp)? line + '\n' : 'r.push(' + line + ');\n';
    }
    ```

当我们写完这两个函数的时候，我们直接替换上面我们分隔字符串时候得到的字字符串时候打印的函数即可。当然我们会看到很多文章为了压缩代码，将这两个函数合并成一个函数，其实对于我们理解这个问题，还原问题本质并没有实际意义，这里建议还是很开写更清晰。

完整代码如下：

    ```js
    <div id="content"></div>        
    <script type="text/tpl" id="template">
        <p>name: {{this.name}}</p>
        <p>age: {{this.profile.age}}</p>
        {{if (this.sex) {}}
            <p>sex: {{this.sex}}</p>
        {{}}}
        <ul>
            {{for(var i in this.skills){}}
            <li>{{this.skills[i]}}</li>
            {{}}}
        </ul>
    </script>
    ```
    ```js    
    <script type="text/javascript">    
        var mtpl = function(tpl, data) {
            var re = /{{(.+?)}}/g, 
                cursor = 0
                reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,    
                code = 'var r=[];\n';

            // 解析html
            function parsehtml(line) {
                // 单双引号转义，换行符替换为空格,去掉前后的空格
                //对可能包含单双引号的字符串进行字符串连接操作时为避免出错，尽可能转移单双引号
                line = line.replace(/('|")/g, '\\$1').replace(/\n/g, ' ').replace(/(^\s+)|(\s+$)/g,"");
                code +='r.push("' + line + '");\n';
            }
            
            // 解析js代码        
            function parsejs(line) {   
                // 去掉前后的空格
                line = line.replace(/(^\s+)|(\s+$)/g,"");
                code += line.match(reExp)? line + '\n' : 'r.push(' + line + ');\n';
            }    
            
            while((match = re.exec(tpl))!== null) {
                // 开始标签  {{ 前的内容和结束标签 }} 后的内容
                parsehtml(tpl.slice(cursor, match.index))
                // 开始标签  {{ 和 结束标签 }} 之间的内容
                parsejs(match[1])
                // 每一次匹配完成移动指针
                cursor = match.index + match[0].length;
            }
            // 最后一次匹配完的内容
            parsehtml(tpl.substr(cursor, tpl.length - cursor));
            code += 'return r.join("");';
            return new Function(code.replace(/[\r\t\n]/g, '')).apply(data);
        }
        
        var tpl = document.getElementById("template").innerHTML.toString();
        document.getElementById("content").innerHTML = mtpl(tpl,{
            name: "zhaomenghuan",
            profile: { 
                age: 22 
            },
            sex: 'man',
            skills: ['html5','javascript','android']
        });
    </script>
    ```

整体设计思路

1. 根据数据`model`定制 `view`模板
2. 运用正则，字符串方法，数组方法结合进行模板解析
3. 拿到 html字符串， js对象字符串， js代码串，
4. 按照正则匹配到的字符串顺序拼接字符串为可执行’js代码‘字符串，（即模板html字符串转化为js可控代码)，生成动态构造函数
5. 传入`model` 通过 apply 动态改变 函数执行上下文，生成 `model-view` html
6. innerHTML()调用

```js
//模板引擎终版
var TemplateEngine = function(html, options) {
    var re = /<%([^%>]+)?%>/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = 'var r=[];\n', cursor = 0;
    var add = function(line, js) {
        js? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
            (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
        return add;
    }
    while(match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += 'return r.join("");';
    return new Function(code.replace(/[\r\t\n]/g, '')).apply(options);
}
```

[master-origin](https://segmentfault.com/a/1190000005804719#articleHeader8) 

